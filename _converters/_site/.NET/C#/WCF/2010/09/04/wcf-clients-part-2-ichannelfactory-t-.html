I talked <a href="http://ninjaferret.co.uk/blog/?p=98">last time</a> about how I approached building a WCF service and how using "Add Service Reference" was causing me some problems. The next part of my journey into WCF was to look at other ways of managing the client and I came across <strong>IChannelFactory&lt;T&gt;</strong>.

<h2>Creating a proxy client IChannelFactory&lt;T&gt;...</h2>

So, to recap, last time I started by defining the following service:

[sourcecode language="csharp" gutter="false"]
[ServiceContract]
public interface AccountService
{
    [OperationContract]
    [FaultContract(typeof(AccountNotFoundFault))]
    Account Get(int id);

    [OperationContract]
    [FaultContract(typeof(NoMatchingAccountsFault))]
    Account Find(string customerName, AccountType accountType);

    [OperationContract]
    [FaultContract(typeof(InvalidCustomerNameFault))]
    void Create(string customerName, AccountType accountType);
}
[/sourcecode]

The next thing is to look at the original client code within an ASP.NET MVC controller:

[sourcecode language="csharp" gutter="false"]
public ActionResult AddNewAccount(NewAccountCommand newAccountCommand)
{
    // Validate the command
    ...
    // Create the account using the service
    try
    {
        _service.Create(newAccountCommand.CustomerName, newAccountCommand.AccountType);
     }
    catch (InvalidCustomerNameException e)
    {
        // Handle the error
    }
}
[/sourcecode]

How do we get to using the channel factory? As my client is already referencing the service assemblies and using the channel factory we can implement the interface:

[sourcecode language="csharp" gutter="false"]
var channelFactory = new ChannelFactory&lt;AccountService&gt;();
var proxy = channelFactory.CreateChannel();
[/sourcecode]

The proxy that is generated can be passed into the ASP.NET MVC controller as the service.

<h2>So where is the problem?</h2>

The client code above will work... well, it will work in the case where the exceptions are not thrown. When an exception is thrown it will be translated into a <strong>FaultException</strong> therefore the original exception will not be caught. To fix this we could try:

[sourcecode language="csharp" gutter="false"]
public ActionResult AddNewAccount(NewAccountCommand newAccountCommand)
{
    // Validate the command
    ...
    // Create the account using the service
    try
    {
        _service.Create(newAccountCommand.CustomerName, newAccountCommand.AccountType);
     }
    catch (InvalidCustomerNameException e)
    {
        // Handle the error
    }
    catch(FaultException&lt;InvalidCustomerNameFault&gt; fault)
    {
        // Handle the error
    }
}
[/sourcecode]

But now the code is less clean, for each error I want to handle I would have to now catch either just the equivalent <strong>FaultException</strong> or both the normal exception or the <strong>FaultException</strong>.

However, the service is now disposable! I now have to remember to call the <strong>Close()</strong> or <strong>Dispose()</strong> methods at some point to release the resources. When do I call it? I have injected this into the controller so the controller cannot dispose it because it does not know whether there are any other references to this object out there. 

While searching around this problem I came across the <a href="http://old.iserviceoriented.com/blog/post/Indisposable+-+WCF+Gotcha+1.aspx">Indisposable - WCF Gotcha 1</a> article on <a href="http://www.iserviceoriented.com/blog">serviceoriented.com</a>. To summarise, a disposable object can be wrapped in a using statement which will automatically call the <strong>Dispose()</strong> method or you can call the <strong>Dispose()</strong> method yourself (usually in a finally block). However, the proxy that is generated by <strong>ChannelFactory</strong> requires that you call <strong>Abort()</strong> after an exception rather than <strong>Dispose()</strong>.

The pattern that was recommended by the blog article was that we can wrap most of the error handling within a generic method:

[sourcecode language="csharp" gutter="false"]
public static class Service&lt;T&gt;
{
    public static ChannelFactory&lt;T&gt; _channelFactory = new ChannelFactory&lt;T&gt;(&quot;&quot;); 

    public static void Use(UseServiceDelegate&lt;T&gt; codeBlock)
    {
        IClientChannel proxy = (IClientChannel)_channelFactory.CreateChannel();
        bool success = false;
        try
        {
            codeBlock((T)proxy);
            proxy.Close();
            success = true;
        }
        finally
        {
            if (!success)
            {
                proxy.Abort();
            }
        }
    }
}
[/sourcecode]

But that means that rather than making a standard call to the service we now have to change the client code to:

[sourcecode language="csharp" gutter="false"]
public ActionResult AddNewAccount(NewAccountCommand newAccountCommand)
{
    // Validate the command
    ...
    // Create the account using the service
    try
    {
        Service&lt;AccountService&gt;.Use(service =&gt; service.Create(newAccountCommand.CustomerName, newAccountCommand.AccountType);
     }
    catch (InvalidCustomerNameException e)
    {
        // Handle the error
    }
    catch(FaultException&lt;InvalidCustomerNameFault&gt; fault)
    {
        // Handle the error
    }
}
[/sourcecode]

This makes me a little worried because the changes have just made the system untestable, by calling into this static class I have now bound the controller to requiring a WCF service to test.

<h2>Crafting my own proxy...</h2>

In order to keep my code testable I used the above pattern within my own hand-crafted proxies:

[sourcecode language="csharp" gutter="false"]
public class AccountServiceProxy : IAccountService
{
    public void Create(string customerName, AccountType accountType)
    {
        try
        {
            Service&lt;AccountService&gt;.Use(service =&gt; service.Create(customerName, accountType);
        }
        catch(FaultException&lt;InvalidCustomerNameFault&gt; fault)
        {
            throw new InvalidCustomerNameException(...);
        }
    }

    public Account Get(int id)
    {
        try
        {
            Account account = null;
            Service&lt;AccountService&gt;.Use(service =&gt; account = service.Get(id);
            return account;
        }
        catch(FaultException&lt;AccountNotFoundFault&gt; fault)
        {
            throw new AccountNotFoundException(...);
        }
    } 
}
[/sourcecode]

This keeps the client code in tact, it only needs to handle the standard exceptions that it always handled rather than adding anything more because of the faults. A much cleaner solution, in my mind.

<h2>So is there still a problem?</h2>

I think that there is still a problem, I am now having to manually do all of the work that I was hoping that someone else would do for me and this led me to think that I now had a pattern that I was manually applying to all services therefore it should be possible to automate the generation of these proxies; this leads me on nicely to my next post...
